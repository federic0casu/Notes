=============================
  Exercise 2 - 2nd Feb 2022   
=============================

Let h : {0,1}^{*} --> {0,1}^{n} be a hash function that is second pre-image and collision resistant.
Let us now consider the hash function H : {0,1}^{*} --> {0,1}^{n}, built from h() as follows:

	H(x) = 0 || h(x) if x in {0,1}^n
	H(x) = 1 || h(x) if x not in {0,1}^n
	
Argue whether H() is pre-image, second pre-image and collision resistant.

Solution. Before addressing the exercise, let's recall the security properties of a hash function.

[1st pre-image resistance] A hash function H() is considered 1st pre-image resistant if, for any hash y 
it is computationally infeasible to find x such that y = H(x).

[2nd pre-image resistance] A hash function H() is 2nd pre-image resistant if, given an input x', it is
computationally infeasible to find x'' ( x' <> x'') such that H(x') = H(x'').

[Collision resistance] Let H() be a hash function. H() is said to be collision resistant, or strong
collision resistant, if it is computationally infeasible to find a pair <x', x''>, x' <> x'', such
that H(x') = H(x'').

[One-Way Hash Function (OWHF)] Let H() be a hash function. H() is said to be one-way if it is 1st
pre-image resistant and 2nd pre-image resistant.

[Cryptographically Secure Hash Function (CRSHF)] Let H() be a hash function. H() is said to be crypto-
graphically secure if it is 2nd pre-image and collision resistant.

It's important to note that there is no theorem stating "Collision resistance implies 1st pre-image 
resistance," and similarly, there is no theorem stating "2nd pre-image resistance implies 1st pre-image
resistance."

In this case, h() is not 1st pre-image resistant. By exploiting y = H(x) and removing the most significant bit, we obtain h(x), which is not 1st pre-image resistant.

 

=============================
  Exercise 1 - 3rd Feb 2022
=============================

Alice and Bob have to choose an encryption mode between CTR and CBC (both modes require an IV that is
transmitted in the clear). They know the adversary is able to intercept and change messages exchanged
between them. They also know that for some messages the adversary knows the first plaintext block M1
and wants to replace it with another block of his choice, namely A1.

	1. Does CTR make it possible to perform such an attack?
	2. Does CBC make it possible to perform such an attack?
	
Solution. Before addressing the exercise, let's recall how CTR encryption/decryption works.

Encryption:

	   +--------+--------+
	   |   IV   | CTR[i] |               CTR[0] = 0
	   +--------+--------+               CTR[i] = CTR[i-1] + 1
				|
				|
				v
		   +---------+
		   |         |
   k ----->|    E    |
		   |         |
		   +---------+
			    |
			    |
			    v
		     +-----+   	
    x[i] --->| xor |---> y[i]
		     +-----+
		     
Decryption:

	   +--------+--------+
	   |   IV   | CTR[i] |
	   +--------+--------+
			    |
			    |
			    v
		   +---------+
		   |         |
   k ----->|    E    |
		   |         |
		   +---------+
			    |
			    |
			    v
		     +-----+   	
    y[i] --->| xor |---> x[i]
		     +-----+

Unfortunately, the CTR mode is malleable! Let's mount the attack:

	1] The adversary intercepts the first message, i.e., {Y1, IV}.
	2] The adversary knows that Y1 = M1 + E(k, IV || 0) mod 2. He does not need to know the key,
	   because he knows M1!
	3] The adversary applies a perturbation R = M1 + A1 mod 2 to Y1. He obtains:
           Y1' = {M1 + E(k, IV || 0)} + R mod 2 = {M1 + E(k, IV || 0)} + M1 + A1 mod 2 =
               = 2*M1 + E(k, IV || 0) + A1 mod 2 = A1 + E(k, IV || 0) mod 2
        4] The adversary sends {Y1', IV}, successfully impersonating the legitimate sender.
        
        
Maybe CBC is a better option. Let's find out:

	1] The adversary can intercept the first message, i.e., {Y1, IV}.
	2] The adversary knows that Y1 = E(k, M1 xor IV). He applies a perturbation to IV, i.e., 
	   IV' = IV xor M1 xor A1. Then, the adversary sends {Y1, IV'}.
	3] The legitimate receiver decrypts Y1 using IV':
	   D(k,Y1) xor IV' = (M1 xor IV) xor (IV xor M1 xor A1) = (M1 xor M1) xor (IV xor IV) xor A1 =
	                   = A1
	                  
Nope, CBC isn't better than CTR. The problem is a matter of integrity: there is no such mechanism
that protect message's integrity.           



=============================
  Exercise 2 - 3rd Feb 2022
=============================

Given two protocols P1 and P2 with:
	> P1: E(K1, x || H(K2, x)), where E() is a symmetric cipher.
	> P2: x, E(pubK, H(x)), where E() is an asymmetric cipher.
state whether they, respectively, satisfy the following security services:
	1. confidentiality,
	2. integrity
	3. non-repudation
	
Solution.
Confidentiality:
	P1 => Yes, x is encrypted by means of K1 with E().
	P2 => Really? Do i need to answer it?
Integrity:
	P1 => Yes
	P2 => The presented scheme does not provide integrity because, being pubk publicly known,
	      anyone can produce x' <> x, H(x') and encrypt it with pubk. 
Non-repudation:
	P1 => Any symmetric cipher cannot be used for non-repudation purposes. The shared secret,
	      being shared :), cannot be used by a trusted third-party to determine which one of 
	      the legimitate secret's holders produced the message.
	P2 => The public key, being publicly known, cannot be used for non-repudation purposes.



=========================
  Exercise 1 - Apr 2022
=========================

In an electronic auction, bidder Bob casts his bid B encrypting it by means of auctioneer Alice's 
public key, pubKA. Let us assume that a bid is 32 bit unsigned integer.

	1. Argue whether the following protocols 1-6 below are practical and secure w.r.t. a passive
	   attacker who attempts to guess the bid B. A protocol is secure if the guessing attack
	   requires at least 2^{80} steps.
	   
	   	1) B --> A: Bob, E(pubKA, Bob || B)
	   	2) B --> A: Bob, E(pubKA, Bob || B || H(B))
	   	3) B --> A: Bob, E(pubKA, Bob || H(B))
	   	4) B --> A: Bob, R, E(pubKA, Bob || R || B)
	   	5) B --> A: Bob, E(pubKA, Bob || R || B)
	   	6) B --> A: Bob, E(pubKA, Bob || K), E(K, Bob || B)

In the protocols:
	a. E(K, x) represents the symmetric encryption of x by means of K.
	b. H() is a secure hash function whose output size is h-bits.
	c. R is an r-bit random number.
	d. K is a k-bit symmetric random key.
	e. Both R and K are dynamically generated at bidding time.
	
Solution.
[Case 1] Since the attacker knows pubKA and Bob (the latter is sent without encrypting it), he can
mount the following attack:

	B <-- 0
	y <-- E(pubKA, Bob || B) // The attacker can eavesdrops on the channel and intercepts it
	do {
		B' <-- random()
		y' = E(pubKA, Bob || B')
	} while (y != y');
	
Since B in [0, 2^{32}), the attack's complexity is O(2^{32}): the protocol is not secure.

[Case 2] A possible attack:

	B <-- 0
	y <-- E(pubKA, Bob || B || H(B)) // Same reasoning as Case 1
	do {
		B' <-- random()
		y' = E(pubKA, Bob || B' || H(B'))
	} while (y != y');
	
Since B in [0, 2^{32}), the attack's complexity is O(2^{32}): the protocol is not secure.

[Case 3] The attacker manages to obtain H(B):

	B <-- 0
	y <-- E(pubKA, Bob || H(B)) // Same reasoning as Case 1
	do {
		B' <-- random()
		y' = E(pubKA, Bob || H(B'))
	} while (y != y');

Since H() is a secure hash function, the attacker is not able to obtain B from H(B). The attacker 
can always mount a dictionary attack: time complexity = O(2^{32}). Does the protocol make any sense?
No, also the auctioneer would need to attack the hash function to be able to read B!

[Case 4] Since the attacker knows pubKA, Bob and R (the latter is sent without encrypting it), he can
mount the following attack:

	B <-- 0
	y <-- E(pubKA, Bob || R || B) // The attacker can eavesdrops on the channel and intercepts it
	do {
		B' <-- random()
		y' = E(pubKA, Bob || R || B')
	} while (y != y');
	
Since B in [0, 2^{32}), the attack's complexity is O(2^{32}): the protocol is not secure.

[Case 5] The attacker DOES NOT know R. He can mount the following attack:

	B <-- 0
	y <-- E(pubKA, Bob || R || B) // The attacker can eavesdrops on the channel and intercepts it
	do {
		B' <-- random()
		R' <-- random()
		y' = E(pubKA, Bob || R' || B')
	} while (y != y');
	
Since R in [0, 2^r), the attack's complexity is O(2^{32} * 2^r): the protocol is secure IF AND ONLY IF
r >= 48.

[Case 6]

	y <-- E(pubKA, Bob || K) // The attacker can eavesdrops on the channel and intercepts it
	do {
		K' <-- random()
		y' = E(pubKA, Bob || K')
	} while (y != y');
	
	B <-- D(K', E(K, Bob || B))
	
Since K in [0, 2^k), the attack's complexity is O(2^k): the protocol is secure IF AND ONLY IF
k >= 80.



=========================
  Exercise 2 - Apr 2022
=========================

Using a stream cipher.
	Method 1) Let the ciphertext c be computed as c = E(K, x || h(x)), where h() is a hash 
	          function and || is the concatenation operator.
Show that, if the attacker knows the whole plaintext x, (s)he can replace x by an arbitrary x' of his/
her choice and compute c' such that the receiver will verify the message correctly. Assume that x and 
x' are of equal length. Will this attack work too if the encryption is done with one-time-pad?
	Method 2) Is the attack still applicable if the checksum is computed using a MAC, i.e., 
                  c = E(K1, x || MAC(K2, x))

Solution. 

Method 1:
	a. The attacker obtains c = E(K, x || h(x)) = K xor {x || h(x)}. 
	   Let's focus on {x || h(x)}:
	   {x || h(x)} + {x || h(x)} + {x' || h(x')} mod 2 = 2{x || h(x)} + {x' || h(x')} mod 2 =
	   = {x' || h(x')} mod 2
	b. The attacker applies the perturbation r = {x || h(x)} + {x' || h(x')} mod 2 to ciphertext.
	   Then (s)he sends c' = c + r mod 2
	c. The legitimate receiver, upon receiving the message, it decrypts c' as
	   K + c' mod 2 = K + c + r mod 2 = K + (K + {x || h(x)}) + ({x || h(x)} + {x' || h(x')}) =
	   = (K + K) + ({x || h(x)} + {x || h(x)}) + {x' || h(x')} mod 2 = 
	   = 2K + 2{x || h(x)} + {x' || h(x')} mod 2 = {x' || h(x')} mod 2
	   
Method 2: even if the attacker knows x, the attacker does not K2. (S)He could try to guess it but, 
if K2 in [0, 2^{80}], (s)he would waste time: too difficult!



=========================
  Exercise 2 - Jul 2012
=========================

Let us consider the protocol below aimed at establishing a session key Kab between Alice and Bob.
In the protocol, Na and Nb denote two nonces that are generated by Alice and Bob, respectively;
Kb denotes the public key of Bob; and, finally, Pa denotes the shared secret password between Alice
and Bob.

	[M1] A --> B: E(Kb, {Na, Kab})
	[M2] B --> A: E(Kab, {Nb, Na})
	[M3] A --> B: E(Kab, {Nb, Pa})

	1. Analyze the protocol and verify whether it fulfills the key authentication and the key 
	confirmation requirements. Specify the assumptions under which the requirements are fulfilled.
	2. Let us suppose that a session key Kab is compromised. (a) Discuss the consequences. 
	(b) Improve the protocol in order to limit at the minimum the effects of session key being
	compromised.

Solution (1).

With message M1 neither Alice nor Bob can say anything about the session key. Bob, since Kb is 
publicly known, can't say that the session key he has just decrypted comes from Alice. 

With message M2 Alice believes that Kab is the session key between her and the other communicating
party (she is an authority for Na and, upon decryption by means of Kab, she checks Na). Also, with 
the same assumption on Na, Alice believes that Bob believes Kab is the session key shared with her.
The latter belief comes from the fact that Bob is the only one who can decrypt {Na, Kab} correctly
since he's the only one who knows privKb.

With message M3 Bob believes that Kab is the session key between him and the other communicating
party and he believes that Bob is the communicating party. Since Bob is an authority for Nb and, 
upon decryption by means of Kab, he checks Nb and authenticates Alice by means of Pa.

The assumptions are the following:

	1. Alice is an authority for Na as well as Bob is an authority for Nb.
	2. Bob's private key is undisclosed and kept secret.
	3. Pa is undisclosed and only known by Alice and Bob.

Solution (2).

If a session key Kab is compromised, then an adversary can impersonates Alice: Kb is publicly known
(thus an adversary can forge M1), Pa can be obtained decrypting message M3 (thus also message M3 can
be forged).



=========================
  Exercise 3 - Jul 2012
=========================

Let us consider One-Time-Pad (OTP):

	1. discuss whether, and to what extent, it is resistant to a ciphertext-only attack.
	2. discuss whether, and to what extent, it is resistant to a known-plaintext attack.

Solution.

With respect to a ciphertext-only attack, OTP is unconditionally secure. What does it mean? If a 
cipher is unconditionally secure, even an unlimited adversary (an adversary with infinite resources)
cannot break the cipher. Let's find out why.

Consider an adversary who has ciphertext-only capability. In such a scenario, we can state the 
"Perfect Secrecy" property:

	> A cipher is said to be perfectly secret if, given a random variable X defined over P (the
	set composed of all the plaintexts), given a random variable Y defined over C (the set composed
	of all the possible ciphertexts), given any probability distribution for X and Y, ii holds:

				for any x in P, for any y in C ==> Pr(X = x | Y = y) =  Pr(X = x)

What does it mean "perfect secrecy"? 

	1. We modeled the scenario following a probabilistic approach: the information an attacker may 
	have about either on the plaintext or the ciphertext are described as probability distributions.
	2. If a cipher is perfect, an attacker must not be able to gain any additional information about 
	any plaintext by looking at the ciphertexts, that is the probability Pr(X = x | Y = y) must remain
	equals to the a-priori probability Pr(X = x).

It can be proven that, if a cipher is perfectly secret than it is also unconditionally secure.

With respect to a known-plaintext attack, the scenario is the following:

	1. An attacker can compute the key used to encrypt the ciphertext.
	2. If the the key is used once, then the attacker cannot decrypt neither the previous nor the
    subsequent ciphertext. Actually, the attacker has not gain any additional knowledge: (s)he already
	knows the pair <plaintext, ciphertext>. 



=========================
  Exercise 2 - Sep 2013
=========================

The figure shows an identification protocol that allows a mobile station (MS) to identify itself
w.r.t. an access point (AP) where:
	
	A) c is a 128-bit random challenge
	B) r is the corresponding response 
	C) v is 24-bit random initialization vector.

Upon receiving message M2 carrying a challenge c from AP, MS generates an initialization vector v at
random, computes the response r by encrypting c, r = SPRG(k || v) xor c where SPRG(k || v) is a 128-bit
sequence generated by a secure pseudo-random generator. The generator is seeded by {k || v}, where k 
is a long-term cryptographic key secretly shared by AP and MS. Upon receiving the response r from MS 
in message M3, AP computes r' = SPRG(k || v) xor c and returns r' == t to the user.

	1. Does this protocol guarantee identification? Can a passive adversary impersonate a mobile 
	   station?

Let us suppose now that AP sends MS the initialization vector v together with the challenge c in 
message M2 which becomes {c, v} (v in M3 is not necessary anymore).

	2. Define a dictionary attack against this variant of the protocol and evaluate the size in 
	   bytes of the dictionary.

Protocol:

	[M1] MS --> AP:  REQ 
	[M2] AP --> MS: c
	[M3] MS --> AP: v, r
	[M4] AP --> MS: YES/NO

Solution (1) - An attacker can eavesdrops on the channel. Thus, (s)he can record a run of the protocol: let's call 
it c*, v* and r* the quantities obtained by the attacker. By just computing one xor, the adversary 
can obtain the key-stream used to generate r*: SPRG(k || v*) = r xor c.

Now, an adversary can impersonate the MS by just using v* and SPRG(k || v*) previously computed:

	[M1] ADV --> AP:  REQ 
	[M2] AP --> ADV: c
	[M3] ADV --> AP: v*, r = SPRG(k || v*) xor c
	[M4] AP --> MS: YES

Solution (2) - Now the protocol is different:

	[M1] MS --> AP:  REQ 
	[M2] AP --> MS: c, v
	[M3] MS --> AP: r
	[M4] AP --> MS: YES/NO

As it was before, an attacker can eavesdrops on the channel and (s)he can obtain the quantity:
									z = SPRG(k || v) = r xor c

v is 24-bit integer: there are only 2^{24} possible values for z. An attacker can record as many 
messages (s)he wants to build the following table:

									| v |      z      |
									| 0 | something_0 |
									| 1 | something_1 |
									|   |     ...     |
									| N | something_N |

If N = 2^{24} then the probability to find z related to the eavesdropped v is 1. The dictionary size 
is 2^{24} * (128 / 8) = 2^{24} * 16 = 2^4 * 2^4 MB = 256 MB (the attacker does not need to store v;
the table can be indexed using v).

If N < 2^{24} the the probability to find z related to the eavesdropped v is N/{2^{24}}. The larger N, 
the larger the probability to find z.



=========================
  Exercise 2 - Feb 2016
=========================

Alice and Bob use one-time pad (OTP) and have agreed on a perfectly random key K. Alice will send Bob
the answer to the question “Are you taking SNCS?” as either ‘Y’ or ‘N’ encoded in their ASCII 
representation (1011001 and 1001110, respectively). The adversary knows nothing about the key but 
intercepts the cipher-text c exchanged between Alice and Bob: 1001110.

	1. What cipher-text c’ should the adversary send Bob to flip Alice’s message?

	2. Alice decides to use a secure hash function h() and transmits the cypher-text c" obtained 
	   from enciphering m||h(m), where m is the clear-text message and || is the concatenation 
	   operator. Can it be of any help?

	3. Without using anything other than OTP, how can Alice and Bob solve this problem? 
	   (Hint: use two keys)

Solution (1) - OTP is malleable, i.e., an attacker can apply a perturbation to the ciphertext that
leads to a predictable transformation of the plaintext. The attacker, to flip Alice's message, should
compute the perturbation that leads to the result the attacker wants.

1001110 = Y xor K --> 1011001 +
                      kkkkkkk = 
					  ---------
					  1001110

1001110 = N xor K --> 1001110 +
                      kkkkkkk = 
					  ---------
					  1001110

perturbation r = 'Y' xor 'N' = 1011001 xor 1001110 = 0010111 

Let's prove that, if the attacker applies r to the ciphertext in any scenario (s)he can flip Alice's 
message.

Alice sends 'Y':
	1. The attacker computes c' = c xor r = 1001110 xor 0010111 = 1011001
	2. Bob receives 1011001 and decrypts: 1011001 xor K = (1001110 xor 0010111) xor K =
	                                                    = ((1011001 xor K) xor 0010111) xor K =
														= 1011001 xor 0010111 = 1001110 = 'N'

Alice sends 'N':
	1. The attacker computes c' = c xor r = 1001110 xor 0010111 = 1011001
	2. Bob receives 1011001 and decrypts: 1011001 xor K = (1001110 xor 0010111) xor K =
	                                                    = ((1001110 xor K) xor 0010111) xor K =
														= 1001110 xor 0010111 = 1011001 = 'Y'

Solution (2) - Such encryption scheme would not be of any help because:

	1. The attacker can still apply a perturbation that lead to flip Alice's message. The 
	   perturbation should be applied only to the first "field" of the encrypted message.
	2. An attacker can compute the "digest of the perturbation" as well: 
	   h('Y' xor 'N') = h('Y') xor h('N') 
	3. The new perturbation would be: r' = ('Y' xor 'N') || h('Y') xor h('N')

Once Bob decrypts the tampered cypher-text, he obtains: 
				m xor ('Y' xor 'N') || h(m) xor h('Y') xor h('N')

Case 1: m = 'Y' b-->  'Y' xor ('Y' xor 'N') || h('Y') xor h('Y') xor h('N') = 
                    = ('Y' xor 'Y') xor 'N' || [h('Y') xor h('Y')] xor h('N') =
					= 2('Y') xor 'N' || 2[h('Y')] xor h('N') =
                    = 'N' || h('N')

Case 2: m = 'N' b-->  'N' xor ('Y' xor 'N') || h('N') xor h('Y') xor h('N') = 
                    = 'Y' || h('Y')



=========================
  Exercise 2 - Jan 2017
=========================

A client C and a Server S share a password PI. Furthermore, client C knows the public key PKs of 
server S. Client and server are equipped with computationally secure hash functions, symmetric 
and asymmetric ciphers. Finally, client and server clocks are not synchronized. Under these 
assumptions, client and server attempt to establish a symmetric session key Kcs by means of the 
following key establishment protocol:

	[M1] C --> S: E(PKs, {C, S, Nc, PI, Kcs})
	[M2] S --> C: E(Kcs, {S, C, Nc, Ns})
	[M3] C --> S: Ns

where the kind of encryption scheme, symmetric or asymmetric, is clear from the context.

	1. Argue whether the protocol satisfies the confidentiality of the password PI in the 
	   case of ciphertext-only attack.
	2. Assume now the adversary gets hold of a session key Kcs* and records the protocol instance
	   {M1*, M2*, M3*} that led to that key establishment.
	   	a. Argue whether the confidentiality of password PI is still guaranteed under this 
		   assumption.
		b. Argue whether the protocol suffers from a replay attack.
		c. If the protocol suffers from any of these attacks, modify it in order to prevent them.

Solution (1) - To disclose long-term password PI, the attacker can extract it from message M1.
Let's assume that the attacker records an instance of the protocol, thus obtaining {M1, M2, M3}.
The attacker knows PKs (it is publicly known), C and S. The quantities Nc, PI and Kcs are unknowns.
One possible attack could a brute force attack whose complexity is O(2^n * 2^p * 2^k), where n, 
p and k are the bit-size of nonce Nc, password PI and key Kcs. If (n+p+k) > 80, then we can state 
that the protocol ensure the confidentiality of the password PI.
Another possible attack could be the following:
	1. From M3 the attacker obtains Ns.
	2. By looking at M2, the attacker would be able to find Nc and Kcs by iterating through all the possible
	   session keys and all the possible nonces. Attack's complexity O(2^k * 2^n)
	3. Having found Nc and Kcs, the attacker could find PI in O(2^p).
The total attack complexity is O(2^k * 2^n) + O(2^p). If (k+n) > p, then the attack's complexity
can be further simplified as O(2^k * 2^n); if p > (k+n), the attack complexity is O(2^p). In both cases, 
we can state that PI's confidentiality is satisfied if p > 80.

Solution (2.a) - Knowing Kcs*, an attacker can decrypt message M2, obtaining Nc. To disclose password 
PI, an attacker could mount a brute force attack on message M1:

	Input: PKs, C, S, Nc, Kcs, M1
	for i in range(0, 2^p):
		tmp = E(PKs, {C,S,Nc,i,Kcs})
		if tmp == M1
			return i

Attack's complexity: O(2^p). If p is not sufficiently large, PI's confidentiality is not satisfied.

Solution (2.b) - Since server is not an authority on Nc, message M1 can be replayed! A possible 
solution for replay attacks could be the following:

	[M0] S --> C: Ns
	[M1] C --> S: E(PKs, {C, S, Nc, Ns, PI, Kcs})
	[M2] S --> C: E(Kcs, {S, C, Nc, Ns'})
	[M3] C --> S: Ns'

Notice that Ns <> Ns'. If Ns' were some how related to Ns, then an active adversary could compute Ns'
and impersonates the client.