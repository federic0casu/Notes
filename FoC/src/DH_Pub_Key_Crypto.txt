==================================
   Diffie-Hellman Key Exchange              
==================================

The DHKE protocol was first presented in November 1976 (New Directions in Cryptography, IEEE 
Transactions on Information Theory).

The DHKE protocol is based on a one-way function: discrete logarithm. Is it really difficult to compute 
a discrete logarithm? It depends on the set we are working with. 

Please, pay attention: the DHKE protocol, as the name suggests, is only a key exchange protocol, that
is it could not be used nor to secure communications (encryption) neither to implement a digital signa-
ture scheme.

So, it's time to talk about the mathematical foundations needed by the DHKE protocol:
	
	1) DHKE operates in a multiplicative group called Zp^{*}. The main property of Zp^{*} is that
	   its elements are the set of integers that are coprime to p and smaller than p. In 
	   mathematical terms, the definition of Zp^{*} is as follows:
	   
	   Zp^{*} = {i in Z | i < p and gcd(i, p) = 1}.

	   Moreover, p has a very important property: it's a prime number. Being prime, any integer 
	   in the range [0, p-1] also belongs to Zp^{*}.
	
	2) Primitive element => Let Zp be a multiplicative group. Let g be an element of Zp; g is
	   called generator (or primitive element) if, for any element z in Zp, exists x in Zp such
	   that g^x mod p = z. Also, we can state that an element of a group is called generator if
	   it has maximum order, i.e., card{g} = |Zp|. 
	   
	3) Let p be prime and g in Zp^{*} be a primitive element (or generator). DHKE protocol works
	   with those two parameters: they are public and they could be agreed a-priori.
	   
	4) DISCRETE LOGARITHM PROBLEM: given a multiplicative group Zp^{*}, where p is prime. Given 
	   a generator of Zp^{p}, g. Given y in Zp^{*} find x such that y = g^x mod p, i.e., 
	   x = log_{g} y mod p
	   
How does DHKE protocol use p and g to securely exchange a key? The DHKE protocol is composed of 2
phases: SETUP phase and ONLINE phase.

SETUP PHASE: Alice and Bob agreed on the "large" prime p and a generator g. There is no need to 
securely store p and g: they can be publicly known.

ONLINE PHASE (key exchange):

	0) Both Alice and Bob compute a random integer. Let's call a the random integer generated by
	   Alice and b the random integer generated by Bob. Random integers a and b are called 
	   ephemeral keys. 
	1) [M1] Alice -> Bob : "Alice", YA = g^a mod p
	2) [M2] Bob -> Alice : "Bob",   YB = g^b mod p
	3) Bob, upon receiving message M1, computes Kab = (YA)^b mod p = (g^a)^b mod p = g^{ab} mod p.
	   After computing Kab, Bob deletes the ephemeral key b.
	3) Alice, upon receiving message M2, computes Kab = (YB)^a mod p = (g^b)^a mod p = g^{ab} mod p
	   After computing Kab, Alice deletes the ephemeral key a.
	
Both Alice and Bob share the same secret key.

So, how secure is the DHKE protocol? The Diffie-Hellman problem is no more secure than the Discrete
Logarithm problem. What does this mean? If an attacker were able to resolve either a = log_{g} YA or 
b = log_{g} YB, then the Diffie-Hellman protocol could be broken.

Another useful property is non-interactivity. What does it mean? To establish a secret shared key,
Bob does not need to synchronously respond to Alice's message. Let's make an example:

	1) Both Alice and Bob publish their public key on their Facebook's account. 
		Alice public key: YA = g^a mod p
		Bob public key: YB = g^b mod p
	2) Alice wants to send a confidential message to Bob. She consults Bob's Facebook account and
	   downloads his public key YB. Then, Alice computes the secret key as Kab = (YB)^a mod p.
	3) Upon receiving Alice's encrypted message, Bob consults Alice's Facebook account and
	   downloads her public key, YA. Similarly to what Alice did, Bob computes the secret key as
	   Kab = (YA)^b mod p = g^{ab} mod p. Now, Bob can correctly decrypt the received message.


==================================
     Man-In-The-Middle Attack              
==================================

As with any public encryption scheme, the DHKE protocol is susceptible to various types of Man-in-the-
Middle (MITM) attacks. Why? Because the protocol lacks authentication!

Let's analyze the attack:

	[M1] Alice --> Bob: "Alice", YA = g^a mod p
	
	(The adversary intercepts message M1 and substitutes YA with YA' = g^c mod p.
	 The adversary controls c, i.e, he generated it.)
	 
	Bob receives "Alice", YA' = g^c mod p. Since there is no authentication/integrity control,
	Bob believes that the message comes from Alice, thus he believes that YA' is Alice's public
	key. Bob computes the shared secret key as Kbc = (g^c)^b mod p = g^{cb} mod p.
	
	[M2] Bob --> Alice: "Bob", YB = g^b mod p
	
	(The adversary intercepts message M2 and substitutes YB with YB' = g^c mod p.
	 As we said before, the adversary controls c, i.e, he generated it.)
	 
	Alice receives "Bob", YB' = g^c mod p. Since there is no authentication/integrity control,
	Alice believes that the message comes from Bob, thus she believes that YB' is Bob's public
	key. Alice computes the shared secret key as Kac = (g^c)^a mod p = g^{ca} mod p.
						
Whenever Alice or Bob sends a message, the adversary intercepts it and decrypts it with the respective
secret key Kbc or Kac. Once the adversary reads what the encrypted message carried, he encrypts it
once again with the respective recipient's secret key.


==================================
         Generalized DLP              
==================================

The Discrete Logarithm Problem can be defined over any finite cyclic group! What do we need?

Definition 1 [Generalized DLP]. Given a finite cyclic group G, |G| = n, and a group operation, 
let's call it o, we can define the generalized DLP as:

	Given y in G, find 1 <= x <= n in G such y = (a) o (a) o ... o (a)
                                                    |                     |
                                                    +---------------------+
                                                            x times


==================================
        Algorithms for DLP              
==================================

There two classes of algorithm that can be used to solve the discrete logarithm problem: generic
algorithms and non-generic algorithms. The former class fo algorithms works in any finite cyclic group,
regardless of the kind of operation or the type (should we say size?) of the generator.

[1] Brute Force Attack ==> The running time is in the order of O(|G|). The bigger the set (in terms of
number of elements), the harder it is to solve DLP. By just looking at it, we can understand that, in 
order to ensure a certain level of security, the DHKE protocol could not run over any Zp^{*}: we
should use large primes.

[2] Shank's Baby-Step Giant-Step Method ==> The running time is in the order of O(sqrt{|G|}). Also, 
    the storage complexity is in the order of O(sqrt{|G|}).

[3] Pollard's Rho Method ==> The running time is in the order of O(sqrt{|G|}).

The most important generic algorithm we should focus on is the following.

[4] Pohlig-Hellman Algorithm ==> It exploits the Chinese Remainder Theorem (CRT). The intuition behind 
    is simple: the algorithm breaks down the DLP into "smaller" sub-groups of G. The running complexity is

			O(sum_{i} e_{i} (log|G| + sqrt{p_i}))

where p_{i} are the integer factors of |G| and e_{i} are the exponents related to p_{i}. The running
complexity depends mostly on the order of the factors p_{i}: if each factor p_{i} is small than the 
algorithm is efficient! To ensure a security level of 80 bits, the smallest factor of |G| must be in
the order of 2^{160}.



==================================
          DLP Security              
==================================

The security of the Diffie-Hellman key exchange protocol relies on the assumption that 
computing discrete logarithms modulo p is computationally difficult. However, if p and 
the chosen generator g are poorly selected, it may be feasible for an adversary to compute
discrete logarithms efficiently. Later we'll describe the small subgroup confinement 
attack, i.e., an attack that is made possible thanks to the particular properties of 
Zp^{*}.

Definition 2 [Cyclic Group]. Consider a set of integers {1, ..., p-1}, where p is prime, 
as well as the operation (x) modulo p. (Zp^{*}, x) is said to be a finite, abelian 
cyclic group:

	1. Finite because the set of integers {1, ..., p-1} is finite.
	2. (Zp^{*}, x) is a group because the operation it is closed, commutative, associative,
	it has an identity element and an inverse element for each integer in {1, ..., p-1}.
	3. Cyclic because it exists al least an element g, called generator, which its order
	is maximum, i.e., ord(g) = |Zp^{*}| = p-1.

Theorem 1. Let G be a finite group. Then for every a in G it holds that:
	1. a|G| = 1 (Generalization of Fermatâ€™s Little Theorem).
	2. ord(a) divides |G|

Theorem 2. Let G be a finite cyclic group. Then it holds that:
	1. The number of primitive elements of G is phi(|G|).
	2. If |G| is prime, then all elements a <> 1 in G are primitive elements.

Theorem 3 [Cyclic Subgroup Theorem]. Let G be a cyclic group. Then every element a in G 
with ord(a) = s is the primitive element of a cyclic subgroup with s elements.

Theorem 4 [Essential to mount a small subgroup confinement attack]. Let G be a finite group.
Let g be a generator fo G. Then, for every integer k that divides |G| = n, it exists a 
subgroup H whose cardinality is |H| = k and at least one generator that ca be computed as
g^{|G|/|K|} = g^{n/k}. H consists exactly of the elements a in G which satisfy the condition
a^{k} = 1. There are no other subgroups.

A small confinement can be mounted by exploiting Theorem 4:

	1. An adversary knows p and g (these are public parameters). Assume that Alice and Bob
	agreed on exchange a secret key using parameters p and g. Alice, start the DHKE proto-
	col and sends to Bob message M1: "Alice", g^a mod p.
	2. The adversary intercept message M1. (S)he knows both g and p so (s)he can compute 
	group's cardinality |Zp^{*}| = p-1. Even if the latter is a very big integer, we know 
	at least one factor: 2. The adversary substitutes g^a mod p with (g^a)^{(p-1)/2} mod p.
	3. g^((p-1)/2) is a generator of a smaller subgroup! Now the adversary can exploits
	generic or non-generic algorithm to solve the discrete logarithm problem!





































