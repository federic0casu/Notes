==================================
          Block Ciphers          
==================================

Block ciphers, as the name suggests, encrypt block of bits (while stream ciphers encrypt one bit at 
time). What is the mathematical (rigorous) definition of a block cipher? 

Definition 1. [Block cipher] A  block cipher is a keyed permutation; in other words, the cipher itself
defines a bijective permutation that maps each element of the plaintext space to exactly one element of
the ciphertext space, as a function of the key.

The algorithm implemented by a block cipher is nothing more than a deterministic algorithm; it's the 
key that introduces randomness into the encryption process. Let me explain better:

    a. Consider the plaintext and ciphertext space; both are composed of integers belonging to 
       [0, 2^n - 1].
    b. A block cipher implements a one-to-one mapping between the plaintext space and the ciphertext 
       space: each plaintext is linked exactly to an element of the ciphertext space. The mapping is
       chosen by the key; each key defines one possible mapping.

It can be proven that a block cipher can be a perfect cipher, but only under certain circumstances.


==================================
	True Random Ciphers          
==================================

Let Perm be the set whose elements are all the possible permutations of {0,1}^n -> {0,1}^n. Since 
Card[{0,1}^n] = 2^n, Card[Perm] = (2^n)!

A True Random Cipher is a block cipher with the following properties:

	1. Implements all the possible permutations in Perm.
	2. Randomly select a permutation as a function of the key.
	
Fact 1. A true random cipher is perfect for Shannon.

Discussing stream ciphers, we've seen that it is possible, albeit impractical, to implement a perfect 
cipher. Unfortunately, in practice, a perfect block cipher cannot be implemented. To implement all the 
possible permutations in Perm, a block cipher should have keys whose size (in bits) is

	sizeof(key) = log_{2}[(2^n)!] ~ (n - 1.44)(2^n)
	
The number of bits required to index all the possible permutations in Perm grows exponentially with 
the block size. This means, in practice, a perfect block cipher cannot be implemented because:

	1. If the block size is too small (with the goal of making practical keys), an attacker could 
	   mount a brute-force attack by enumerating all the possible permutations.
	2. To discourage a brute force attack, we should use block that at least are 64 bits long. 
	   With those numbers, we have keys that are roughly 64(2^{64}) bits-long!
	   
What is the best we can hope for?


==================================
    Pseudorandom permutations               
==================================

A pseudorandom permutation is a practical implementation of a block cipher. The mathematical 
definition of a pseudorandom permutation is as follows:

==> Pseudorandom permutation. Let {0,1}^k and {0,1}^b be sets of integers. A keyed permutation
    implements a subset of all possible permutations of {0,1}^n ==> {0,1}^n as a function of a key 
    k in {0,1}^k. A keyed permutation is considered a pseudorandom permutation if it is 
    indistinguishable from a truly random permutation.
    
What does it mean for a keyed permutation to be indistinguishable? Let's consider the following 
scenario:

	1. An oracle has both a truly random permutation and a keyed permutation. It takes an input x 
	   and returns, at random, an element coming from the true random permutation or an element
	   of the keyed permutation as a function of a randomly choosen key.
	2. An attacker can access the oracle but he cannot look into it. From the perspective of the
	   attacker, an oracle is a black box.
	3. The keyed permutation is said to be indistinguishable, i.e., a pseudorandom permutation, if
	   the attacker cannot distinguish whether the output of the oracle comes from a true random 
	   permutation or from the keyed permutation.
	   
	
=========================================
 Brute Force Attacks and False Positives               
=========================================

As usual, any encryption scheme could be broken through a brute force attack. Specifically:

	1. Consider a pair <pt, ct> (it is a known-plaintext attack).
	2. The algorithm is as follows:
		k <= -1;
		do 
			k <= k + 1;
			tmp <= Enc(k, pt);
		while (tmp != ct);
	3. The encryption algorithm, by definition, is a keyed pseudorandom permutation. That means
	   there are at maximum 2^k possible mapping for each plaintext: the complexity is around
	   O(2^k).
	   
It is important to notice that there could be false positives. Why is there a non-null probability of
false positives? Because we expect that more than one key maps a given plaintext to a ciphertext. 
So, in many cases, we need more than one pair to have a certain level of confidence that the key we've
just found is the correct key.

Example 1: Let <E,D> be a block cipher whose block size is n and key size is k. Given a pair <pt, ct>, 
how many false positives would you expect? 
A block cipher is an instance of a pseudorandom permutation, that is, given an element x in {0,1}^n (a 
plaintext) it returns an element in {0,1}^n as a function of the key. Assuming the key is uniformly
distributed, also the output of the pseudorandom permutation can be represented as a uniform random
variable.

Pr[E(k,pt) = ct] = (1/2)^n

It follows that, since the number of possible keys is 2^k, the expected number of false positives is
(2^k / 2^n).

Theorem 1 [Expected number of False Positives]. Let <E,D> be a block cipher whose block size is n and 
key size is k. Let <pt, ct> be a plaintext and the corresponding ciphertext. The expected number of keys that maps pt into ct is 2^(k-n).

Example 2: Skypjack with k = 80, n = 64.
	1. The expected number of keys is 2^{80 - 64} = 2^{16}.
	2. A pair <pt, ct> is not sufficient for an exhaustive key search. 
	
Theorem 2. Given a block cipher with a key lenght of k bits and a block size of n bits, as well as t
plaintext-ciphertext pairs, <pt_{1}, ct_{1}>, ..., <pt_{t}, ct_{t}>, the expected number of false keys
which encrypt all plaintexts to the corresponding ciphertexts is 2^{k-tn}.


==================================
       Multiple Encryptions               
==================================

Shortly after DES was proposed, two major criticisms against the cryptographic strength of DES
centered around two arguments:
	1. The key space is too small, i.e., the algorithm is vulnerable against brute-force
	   attacks.
	2. The design criteria of the S-boxes was kept secret and there might have existed an 
	   analytical attack that exploits mathematical properties of the S-boxes, but which
	   is only known to the DES designers (we should not rely on security through obscurity).
	   
We discuss both types of attacks below. However, we also state the main conclusion about DES security
already here: despite very intensive cryptanalysis over the lifetime of DES, current analytical 
attacks are not very efﬁcient. However, DES can relatively easily be broken with an exhaustive key-
search attack and, thus, plain DES is not suited for most applications any more.

For clariﬁcation, let’s recall the principle of an exhaustive key search (or brute-force attack):

	Algorithm 1 [DES exhaustive key search]. Let <pt, ct> be a pair of plaintext, ciphertext.
	The exhaustive key search algorithm is as follows:
	
		K = 56;
		for (k = 0; k < 2**K; k++)
			if (D(k, ct) == pt)
				return k;

Note that there is a small chance of (1/2)^{16} that an incorrect key is found, i.e., a key k which 
decrypts only the one ciphertext y correctly but not subsequent ciphertexts. If one wants to rule out 
this possibility, an attacker must check such a key candidate with a second plaintext–ciphertext pair.

How can DES block cipher be strengthened? One approach is through multiple encryption. Let's first 
analyze what happens if we double the key space (2DES).

Definition 2 [2DES]. 2DES is a block cipher whose block size is n = 128 bits and key size k' = 2*k.


ENCRYPTION: y = E(Kr, E(Kl, x)) 

				+---------+           +---------+
			  x	|         |     z     |         |     y
		     ==========>|    E    |==========>|    E    |==========>
				|         |           |         |
				+---------+           +---------+
				     +                     +
				     |			   |
			 Kl =========+	       Kr =========+
			 

DECRYPTION: y = D(Kl, D(Kr, x))

				+---------+           +---------+
			  x	|         |     z     |         |     y
		     ==========>|    D    |==========>|    D    |==========>
				|         |           |         |
				+---------+           +---------+
				     +                     +
				     |			   |
			 Kr =========+	       Kl =========+

Is it really secure than simple DES? Let's find out:
	
    Algorithm 2 [Meet-In-The-Middle Attack]
    Given a pair <x,y>:
	1. Compute all the possible intermediate value, i.e., z encrypting x with Ki 
	   (i = 0, ..., 2^k - 1). Build a table sorted with respect z. 
	   Complexity: 2^k encryptions * inserting and sorting a table with 2^k elements => 
	   2^k * log(2^k) ~ k(2^k) => O(k 2^k)
	2. Compute all the possible intermediate values z' by decrypting y with all the possible
	   ritght keys. For each z', search wheter there is a z in the table such that z == z'.  
	   Complexity: 2^k decryptions * searching in a sorted table with 2^k elements =>
	   2^k * log(2^k) ~ k(2^k) => O(k 2^k) 
	   
A brief clarification about the complexity of inserting a value (and keeping it sorted) in a table:
there are many ways to do that. A very simple (and smart one) is to use a binary tree. On average,
inserting an element and keeping the tree sorted after the insertion costs O(log(N)) (N is the number
of nodes). 

Now, let's delve into a more detailed view of the scenario:

	1. Data complexity: O(1), as it is negligibile; we only need a pair <x,y>.
	2. Storage complexity: O(2^k). Actually, the storage complexity is 2^{56} * (sizeof(z) +
	   sizeof(k)) = 2^{56} * (16 + 7) ~ 2^{k} * 2n bits
	3. Time complexity: O(k 2^k) + O(k 2^k) = O(k 2^k) ~ O(2^k)
	
Even though it is not fair to compare the complexity of a plain DES brute-force attack with the
complexity of 2DES, we can say that there is no significant advantage in terms of security: 2DES is 
not more secure than DES. 

Let's again, how can DES block cipher be strengthened? 3DES. 


ENCRYPTION: y = E(K1, D(K2, E(K3, x))) 

			+---------+           +---------+           +---------+
		  x	|         |           |         |           |         |    y
	     ==========>|    E    |==========>|    D    |==========>|    E    |==========>
			|         |           |         |           |         |
			+---------+           +---------+           +---------+
			     +                     +                     +
			     |			   |                     |
		 K1 =========+	       K2 =========+         K3 =========+


DECRYPTION: y = D(K3, E(K2, D(K1, x)))

			+---------+           +---------+           +---------+
		  x	|         |           |         |           |         |    y
	     ==========>|    D    |==========>|    E    |==========>|    D    |==========>
			|         |           |         |           |         |
			+---------+           +---------+           +---------+
			     +                     +                     +
			     |			   |                     |
		 K3 =========+	       K2 =========+         K1 =========+

The encryption process involves encrypting the data with the first 56-bit key (K1), then decrypting it
with the second key (K2), and finally encrypting it again with the third key (K3). 

3DES Meet-In-The-Middle attack:
	1. Time = 2112 (undoable!)
	2. Space = 256 (lot of space!)
	
Key whitening is a technique used in cryptography to enhance the security of encryption algorithms,
particularly block ciphers. The primary purpose of key whitening is to inject additional key material
into the encryption process, making it more resistant to various cryptographic attacks.

The process of key whitening can be summarized as follows:

	1) Initial XOR Operation. The plaintext/ciphertext is XORed with a portion of the secret key.
	2) Encryption or Decryption. The XORed result is then processed through the main encryption or
	   decryption algorithm using the rest of the secret key.
	3) Final XOR Operation. The final output of the encryption or decryption process is XORed with
	   another portion of the secret key.
	   
Encryption:
					+---------+           
		  x	/---\           |         |           /---\    y
	     ==========>|xor|==========>|    E    |==========>|xor|==========>
			\---/           |         |           \---/
			  +             +---------+             +
			  |                  +                  |
			  |	             |                  |
		K1 =======+	   K2 =======+        K3 =======+	        


==================================
         Encryption Modes                
==================================

Encryption modes are methods used to apply block ciphers to messages whose size is larger than the
block size. As we already know, block cipher encrypts fixed-size blocks of data: encryption modes
determine how these blocks are processed to encrypt/decrypt the entire message.

Electronic Codebook (ECB): each block of plaintext is independently encrypted with the same key. 

			   +----------+      	         +----------+
			   |          |      	         |          |
		   X1 ====>|   E(k)   |====>   Y1   ====>|   D(k)   |====> X1
			   |          |    	         |          |
			   +----------+                  +----------+

			   +----------+      	         +----------+
			   |          |      	         |          |
		   X2 ====>|   E(k)   |====>   Y2   ====>|   D(k)   |====> X2
			   |          |    	         |          |
			   +----------+                  +----------+

					      ...

			   +----------+      	         +----------+
			   |          |      	         |          |
		   Xn ====>|   E(k)   |====>   Yn   ====>|   D(k)   |====> Xn
			   |          |    	         |          |
			   +----------+                  +----------+
			   
The ECB mode is the simplest encryption mode that we will encounter. Obviously, there some PROS and 
CONS.

 => Since each block is encrypted independently from the others:
 	1. The encryption/decryption process can be parallelized.
 	2. There is no error propagation: if an error occurs in the i-th block, it will only affect
 	   the i-th block during decryption.
 => For the same reason mentioned before (independent encryption):
 	1. There is no randomization. In other words, identical plaintext will be mapped to identical
 	   ciphertext each time a key is used twice.
 	2. ECB blocks could be reordered. Even if it's not a matter of confidentiality, ECB encryption
 	   mode does not ensure any type of protection against integrity attacks.

Let's talk about the lack of randomization:
	1. Oscar, who is a smart guy, had a brilliant idea to become rich. He studied how the
	   communication protocol between Bank A and B is secured. He found that the messages are 
	   encrypted using AES-128 in ECB mode.
	2. He opened two bank accounts: one at bank A and one at bank B. Then, he started sending
	   small amounts of money from Bank A to Bank B.
		   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		   |D|S|T|:|6|4|8|s|r|-|S|R|C|:|9|4|b|1|r|-|T|O|T|:|1|0|0|$|
		   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        3. Bank A and Bank B do not change secret keys very often. By analizyng the network traffic,
           Oscar started to see messages that are identical: he found the ciphertext corresponding to
           his transactions.
        4. To foul the banks, he replayed his own messages: he's literally making money!
        
Why Oscar was able to perform the attack? ECB lacks of randomization: Oscar was able to detect his
own encrypted messages without even trying to break the cipher! ECB mode does not hide the properties
of the messagges and such vulnerability could be misused.


Cipher Block Chaining (CBC):

ENCRYPTION: y[1] = E(k, x[1] xor IV)
            y[i] = E(k, x[i] xor y[i-1]), i > 1

	1. The first plaintext block is XORed with the IV.
	2. The result is encrypted to produce the first ciphertext block.
	3. Each subsequent plaintext block is XORed with the previous ciphertext block before
	   encryption.
	4. The final ciphertext is the sequence of encrypted blocks.
	
DECRYPTION: x[1] = D(k, y[1]) xor IV
            x[i] = E(k, y[i]) xor y[i-1], i > 1
	
CBC provides better security than ECB mode because it introduces randomization (with IV) and helps
prevent patterns in the plaintext from being observable in the ciphertext. It is widely used in
various cryptographic applications, including secure communication protocols and disk encryption.


The following encryption modes are used to build a stream cipher starting from a block cipher.

Output Feedback Mode (OFB):
	1.The key stream is generated block-wise.
	2. No error propagation.
	3. Suffers from malleability

KEY-STREAM GENERATION: s[1] = E(k, IV)
                       s[i] = E(k, s[i-1]), i > 1

ENCRYPTION: y[i] = x[i] xor s[i], i > 0          + DECRYPTION: x[i] = y[i] xor s[i], i > 0
                                                 +
                       +--------+                +                        +--------+
      IV ------   -----| s[i-1] |                +       IV ------   -----| s[i-1] |
               \ /     +--------+                +                \ /     +--------+
                +           |                    +                 +           |
                |           |                    +                 |           |
	   +---------+      |  	                 +            +---------+      |
	   |         |      |  	                 +            |         |      | 
    K ====>|    E    |------+                    +     K ====>|    E    |------+
	   |         |      |                    +            |         |      |
	   +---------+      |                    +            +---------+      |
                            |                    +                             |
	      		  /---\                  +                           /---\
	    x[i] ========>|xor|========> y[i]    +             x[i] ========>|xor|========> y[i]
		          \---/                  +                           \---/


Cipher Feedback Mode (CFB): CFB is an asynchronous stream cipher as the key stream is also a function
of the ciphertext. IV is a nonce and makes CFB nondeterministic.

ENCRYPTION: y[i] = x[i] xor s[i-1], i > 0        + DECRYPTION: x[i] = y[i] xor [i], i > 0
            s[0] = E(k, IV)                      +             s[0] = E(k, IV)
                                                 +
                       +--------+                +                        +--------+
      IV ------   -----| s[i-1] |--+             +       IV ------   -----| s[i-1] |--+
               \ /     +--------+  |             +                \ /     +--------+  |
                +                  |             +                 +                  |
                |                  |             +                 |                  |
	   +---------+        	   |             +            +---------+             |
	   |         |        	   |             +            |         |             |
    K ====>|    E    |------+      |             +     K ====>|    E    |------+      |
	   |         |      |      |             +            |         |      |      | 
	   +---------+      |      |             +            +---------+      |      |
                            |      |             +                             |      | 
	      		  /---\    |             +                           /---\    |
	    x[i] ========>|xor|========> y[i]    +             x[i] ========>|xor|========> y[i]
		          \---/                  +                           \---/
		          
COUNTER MODE (CTR): 

ENCRYPTION: y[i] = x[i] xor {IV || c[i-1]++}
            c[0] = 0

			      +---------------+---------+
			      |       IV      | COUNTER |
			      +---------------+---------+
					|
					|
				   +---------+
				   |         |
			    K ====>|    E    |------+
				   |         |      |
				   +---------+      |
						    |
				      		  /---\
				    x[i] ========>|xor|========> y[i]
						  \---/

DECRYPTION: x[i] = y[i] xor {IV || c[i-1]++}
c[0] = 0
